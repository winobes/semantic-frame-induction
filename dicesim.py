
from operator import itemgetter
import pickle
import framenet


##------------

def dicesim(A, B):
    A = set(A)
    B = set(B)
    return (( 2 * len(A & B) ) / ( len(A) + len(B) ))


# assume a dict input {frame: list of verbs}
# finds model frame with best dice score for each FN frame
def dicematch(model_frameverbs, fn_frameverbs):
    
    # dict {FN frameID: {model frame: dicesim score with FN frame}}
    frame_matches = dict.fromkeys(fn_frameverbs)
    
    for fn_frame in fn_frameverbs:
        dicesims = dict.fromkeys(model_frameverbs)
        for m_frame in model_frameverbs:
            dicesims[m_frame] = dicesim(fn_frameverbs[fn_frame], model_frameverbs[m_frame])
        frame_matches[fn_frame] = dicesims

    return frame_matches


def dicemax(model_frameverbs, fn_frameverbs):
    dicedict = dicematch(model_frameverbs, fn_frameverbs)

    frame_maxes = dict.fromkeys(fn_frameverbs)

    for fn_frame in fn_frameverbs:
        currentmax = ('',-1)
        for m_frame in model_frameverbs:
            if dicedict[fn_frame][m_frame] > currentmax[1]:
                currentmax = (m_frame, dicedict[fn_frame][m_frame])
        frame_maxes[fn_frame] = currentmax

    return frame_maxes



##------------



# modeled on evaluation.frames_by_frequency
def frame_freqsort(verbdists):
    ig1 = itemgetter(1)
    verbfreqs = {f: list(verbdists[f].items()) for f in verbdists}
    for f in verbdists:
        verbfreqs[f].sort(key=ig1, reverse=True)

    return verbfreqs




def verbmembers_topN(verbfreqs, N):
    verb_rosters = dict.fromkeys(verbfreqs)
    for f in verbfreqs:
        verb_rosters[f] = verbfreqs[f][:N]
        
    return verb_rosters

def verbmembers_cutoffprob(verbfreqs, q):
#   ig1 = itemgetter(1)
    verb_rosters = dict.fromkeys(verbfreqs, list())
    for f in verbfreqs:
        i = 0
        while verbfreqs[f][i][1] >= q:
            verb_rosters[f].append(verbfreqs[f][i])
            i += 1

    return verb_rosters


def roster_to_verblist(verb_roster):
    return [i[0] for i in verb_roster]

def rosters_to_verblists(verb_rosters):
    return {f: roster_to_verblist(verb_rosters[f]) for f in verb_rosters}


##------------

sample_filename = 'sample_m1_F50_alpha0.5_beta0.5_T500burnIn50.pkl'
fn_threshold = 5
model_verb_membership_criterion = 'cutoffprob'
mvmc_topN = 10
mvmc_cutoffprob = .001


def run_dicesim():

    # open and unpickle the specified sample data
    model_dists = pickle.load(open(sample_filename, 'rb'))
    # ..and specifically the verb distributions
    model_verbdists = model_dists[0]
    # reformat {frame: {verb: prob}} to {frame: [(verb, prob)]} and sort lists
    model_verbfreqs = frame_freqsort(model_verbdists)
    
    # for each frame f, remove entries from f's sorted [(verb, prob)] list
    #   that do not belong to f according to the specified criterion;
    #   output {frame: [verbs]}
    if model_verb_membership_criterion == 'cutoffprob':
        model_frameverbs = verbmembers_cutoffprob(model_verbfreqs, mvmc_cutoffprob)
    else:
        model_frameverbs = verbmembers_topN(model_verbfreqs, mvmc_topN)
        
    # retrieve the analogous {frame: [verbs]} dict computed by the framenet module
    fn_frameverbs = framenet.sort_verbs_to_frames(fn_threshold)

    # for each framenet frame, find the best-matching frame generated by our model
    #   as determined by dicesim scores
    dice_results = dicemax(model_frameverbs, fn_frameverbs)

    # todo: output results informatively
    #       look up framenet info
    #       some other stuff

    



    
