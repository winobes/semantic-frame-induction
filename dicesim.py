
from operator import itemgetter
import pickle

import framenet

##------------

def dicesim(A, B):
    A = set(A)
    B = set(B)
    return (( 2 * len(A & B) ) / ( len(A) + len(B) ))


# assume a dict input {frame: [verbs]}
# outputs {FN frame f: {model frame m: dicesim(f, m)}}
def dicescores(model_frameverbs, fn_frameverbs):
    
    # dict {FN frameID: {model frame: dicesim score with FN frame}}
    frame_matches = dict.fromkeys(fn_frameverbs)
    
    for fn_frame in fn_frameverbs:
        dicesims = dict.fromkeys(model_frameverbs)
        for m_frame in model_frameverbs:
            dicesims[m_frame] = dicesim(fn_frameverbs[fn_frame], model_frameverbs[m_frame])
        frame_matches[fn_frame] = dicesims

    return frame_matches


# this is currently unreadably formatted but I'm working on it
# def print_dice_table(frame_matches):
#     print('_______|')
    
#     for f in frame_matches:
#         print(' '.join([f.rjust(6),'|']+[str(round(frame_matches[f][m],4)).rjust(5) for m in frame_matches[f]]))
#         print('       |')
        
        


# outputs {FN frameID f: (ID of best Dice-matched frame m, dicesim(f, m))}
def dice_maxmatch(model_frameverbs, fn_frameverbs):
    dicedict = dicescores(model_frameverbs, fn_frameverbs)
    fn_bestmatches = dict.fromkeys(fn_frameverbs)
    for fn_frame in fn_frameverbs:
        currentmax = ('',-1)
        for m_frame in model_frameverbs:
            if dicedict[fn_frame][m_frame] > currentmax[1]:
                currentmax = (m_frame, dicedict[fn_frame][m_frame])
        fn_bestmatches[fn_frame] = currentmax

    return fn_bestmatches




##------------



# modeled on evaluation.frames_by_frequency
def frame_freqsort(verbdists):
    ig1 = itemgetter(1)
    verbfreqs = {f: list(verbdists[f].items()) for f in verbdists}
    for f in verbdists:
        verbfreqs[f].sort(key=ig1, reverse=True)

    return verbfreqs




def verbmembers_topN(verbfreqs, N):
    verb_rosters = dict.fromkeys(verbfreqs)
    for f in verbfreqs:
        verb_rosters[f] = [i[0] for i in verbfreqs[f][:N]]
        
    return verb_rosters

def verbmembers_cutoffprob(verbfreqs, q):
#   ig1 = itemgetter(1)
    verb_rosters = dict.fromkeys(verbfreqs)
    for f in verbfreqs:
        verb_rosters[f] = list()
        i = 0
        while verbfreqs[f][i][1] >= q:
            verb_rosters[f].append(verbfreqs[f][i][0])
            i += 1

    return verb_rosters


def roster_to_verblist(verb_roster):
    return [i[0] for i in verb_roster]

def rosters_to_verblists(verb_rosters):
    return {f: roster_to_verblist(verb_rosters[f]) for f in verb_rosters}





##------------------------##------------------------##
## ..and now to actually run the thing
## (should extract some of this to a wrapper, probably)

sample_filename = 'sample_m1_F50_alpha0.5_beta0.5_T500burnIn50.pkl'
fn_threshold = 5
model_verb_membership_criterion = 'cutoffprob'
#model_verb_membership_criterion = 'topN'
mvmc_topN = 4
mvmc_cutoffprob = .01


#print_dice_results(dice_results):


def run_dicesim():

    # open and unpickle the specified sample data
    model_dists = pickle.load(open(sample_filename, 'rb'))
    # ..and specifically the verb distributions
    model_verbdists = model_dists[0]
    # reformat {frame: {verb: prob}} to {frame: [(verb, prob)]} and sort lists
    model_verbfreqs = frame_freqsort(model_verbdists)
    
    # for each frame f, remove entries from f's sorted [(verb, prob)] list
    #   that do not belong to f according to the specified criterion;
    #   output {frame: [verbs]}
    if model_verb_membership_criterion == 'cutoffprob':
        model_frameverbs = verbmembers_cutoffprob(model_verbfreqs, mvmc_cutoffprob)
    else:
        model_frameverbs = verbmembers_topN(model_verbfreqs, mvmc_topN)
        
    # retrieve the analogous {frame: [verbs]} dict computed by the framenet module
    fn_frameverbs = framenet.sort_verbs_to_frames(fn_threshold)

    # for each framenet frame, find the best-matching frame generated by our model
    #   as determined by dicesim scores --- currently run_dicesim() also returns
    #   the full dict-of-dicts (dice_scoresheet) along with just the computed matches
    dice_scoresheet = dicescores(model_frameverbs, fn_frameverbs)
    dice_results = dice_maxmatch(model_frameverbs, fn_frameverbs)

    return (dice_scoresheet, dice_results)


    
##------------------------

    
    # todo:
    #   - experiment with the "model_verb_membership_criterion" and its params
    #   - print output/scores informatively
    #   - integrate framenet info into output
    #   - restructure these code files better
    #   - rename some variables and functions for clarity
    #   - some other stuff

    # potentially:
    #   - modify the framenet interface code so labels are ints, not 'int's
    #   - use sets instead of lists in some places

    # questions:
    #   - what does the distribution of dicesim scores for a fixed FN frame
    #     over all of our model's frames look like? Is there a lot of verb-overlap
    #     between the different frames induced by our own model?
    



    
