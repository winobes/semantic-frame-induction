
import string
from operator import itemgetter
import pickle

import framenet

##------------

def dicesim(A, B):
    # [make sure A,B aren't sets already?]
    A = set(A)
    B = set(B)
    return (( 2 * len(A & B) ) / ( len(A) + len(B) ))


# assume a dict input {frame: [verbs]}
# outputs {FN frame f: {model frame m: dicesim(f, m)}}
def dicescores(model_frameverbs, fn_frameverbs):
    
    # dict {FN frameID: {model frame: dicesim score with FN frame}}
    frame_matches = dict.fromkeys(fn_frameverbs)
    
    for fn_frame in fn_frameverbs:
        dicesims = dict.fromkeys(model_frameverbs)
        for m_frame in model_frameverbs:
            dicesims[m_frame] = dicesim(fn_frameverbs[fn_frame], model_frameverbs[m_frame])
        frame_matches[fn_frame] = dicesims

    return frame_matches


# outputs {FN frameID f: (ID of best Dice-matched frame m, dicesim(f, m))}
def dice_maxmatch(model_frameverbs, fn_frameverbs):
    dicedict = dicescores(model_frameverbs, fn_frameverbs)
    fn_bestmatches = dict.fromkeys(fn_frameverbs)
    for fn_frame in fn_frameverbs:
        currentmax = ('',-1)
        for m_frame in model_frameverbs:
            if dicedict[fn_frame][m_frame] > currentmax[1]:
                currentmax = (m_frame, dicedict[fn_frame][m_frame])
        fn_bestmatches[fn_frame] = currentmax

    return fn_bestmatches


##------------------------

# DICE_SCORESHEET = {f: {v: dicesim(f,v)}}
# DICEMAX = {f: (v, dicesim(f,v))}

# VERBDISTS = {f: {v: p}}
# VERBFREQS = {f: [(v, p)] sorted}
# VERB_ROSTER = {f: [v]}


# modeled on evaluation.frames_by_frequency
def frame_freqsort(verbdists):
    ig1 = itemgetter(1)
    verbfreqs = {f: list(verbdists[f].items()) for f in verbdists}
    for f in verbdists:
        verbfreqs[f].sort(key=ig1, reverse=True)

    return verbfreqs


def verbmembers_topN(verbfreqs, N):
    verb_rosters = dict.fromkeys(verbfreqs)
    for f in verbfreqs:
        verb_rosters[f] = [i[0] for i in verbfreqs[f][:N]]
        
    return verb_rosters


def verbmembers_cutoffprob(verbfreqs, q):
    verb_rosters = dict.fromkeys(verbfreqs)
    for f in verbfreqs:
        verb_rosters[f] = list()
        i = 0
        while verbfreqs[f][i][1] >= q:
            verb_rosters[f].append(verbfreqs[f][i][0])
            i += 1

    return verb_rosters


##------------------------


def run_dicesim(sample_filename, mvmc, mvmc_param, fn_threshold):

    # open and unpickle the specified sample data
    model_dists = pickle.load(open(sample_filename, 'rb'))
    # ..and specifically the verb distributions
    model_verbdists = model_dists[0]
    # reformat {frame: {verb: prob}} to {frame: [(verb, prob)]} and sort lists
    model_verbfreqs = frame_freqsort(model_verbdists)
    
    # for each frame f, remove entries from f's sorted [(verb, prob)] list
    #   that do not belong to f according to the specified criterion;
    #   output {frame: [verbs]}
    if mvmc == 'cutoffprob':
        model_frameverbs = verbmembers_cutoffprob(model_verbfreqs, mvmc_param)
    else:
        model_frameverbs = verbmembers_topN(model_verbfreqs, mvmc_param)
        
    # retrieve the analogous {frame: [verbs]} dict computed by the framenet module
    fn_frameverbs = framenet.sort_verbs_to_frames(fn_threshold)

    # for each framenet frame, find the best-matching frame generated by our model
    #   as determined by dicesim scores --- currently run_dicesim() also returns
    #   the full dict-of-dicts (dice_scoresheet) along with just the computed matches
    dice_scoresheet = dicescores(model_frameverbs, fn_frameverbs)
    dice_results = dice_maxmatch(model_frameverbs, fn_frameverbs)

    return (dice_scoresheet, dice_results)



##------------------------
## This section not working yet, sorry for the mess


def compare_verblists(f0, f1):
    f0 = set(f0)
    f1 = set(f1)
    return (f0 & f1, f0 - f1, f1 - f0)

def print_verblist_comparison(f0, f1):
    inboth, f0only, f1only = compare_verblists(f0, f1)

    print('Shared verbs:',*inboth)
    print('Only in first frame:',*f0only)
    print('Only in second frame:',*f1only)


# this is currently unreadably formatted but I'm working on it
#def print_dice_table(frame_matches):
#     print('_______|')
#    tbfrmt = '{:>4}
#     for f in frame_matches:
#         print(' '.join([f.rjust(6),'|']+[str(round(frame_matches[f][m],4)).rjust(5) for m in frame_matches[f]]))
#         print('       |')
        
   

#def compile_report(verbfreqs, model_frameverbs, scoresheet, dice_results):

#    matchlist = [(f, dice_results[f][0]) for f in dice_results]
    
    # quick statistics about distributions of
    #     (1) model,
    #     (2) dice scores (the whole scoresheet),
    #     (3) ultimate FN assignments for model-induced frames, ...
    
    # Features/stats of avg FN vs model-induced frames


    # 'Venn comparison' a la O'Connor

###    for (
    
###    return report


# dice-measure induced frames with other frames from the same model.
#   what could this tell us? what would be a 'healthy' self-dice?
